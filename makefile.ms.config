# These definitions are generated by the kit builder
KIT=1
TARGET_OS=w

##############################################################
#
# Here are some things you might want to configure
#
##############################################################

# off - 0; on - 1
DEBUG?=0

# if your tool is not in the kit directory
# then set this to the pin-2.0-X-Y directory
PIN_HOME ?= ../../../../third_party/pin/src/linux/source/

##############################################################
#
# Typical users will not need to change the stuff below here
#
##############################################################

###############################################################
# Determine target and host CPU. By default, target CPU = host CPU.
# You can override this on the cmd line.
###############################################################
ifndef HOST_ARCH
    ifeq ($(XARCH),64)
        HOST_ARCH=ia32e
    else
        ifeq ($(XARCH),86)
            HOST_ARCH=ia32
        else
            ifeq ($(PROCESSOR_ARCHITEW6432),AMD64)
                HOST_ARCH=ia32e
            else
                ifeq ($(PROCESSOR_ARCHITECTURE),AMD64)
                    HOST_ARCH=ia32e
                endif
                ifeq ($(PROCESSOR_ARCHITECTURE),x86)
                    HOST_ARCH=ia32
                endif
           endif
        endif
    endif
endif
ifndef HOST_ARCH
    $(could not detect building host. please define HOST_ARCH on the command line)
endif

ifndef TARGET
	TARGET=${HOST_ARCH}
endif



##############################################################
# Set the kit versus source tree stuff
##############################################################
ifndef KIT
  KIT = 0
endif

###############################################################
# Define MSVC options for building tools
###############################################################
ifeq (${KIT},0)
    include ../ms.flags
else
    PIN_KIT ?= ../../../../third_party/pin/src/windows
    include $(PIN_KIT)/source/tools/ms.flags
endif

PIN_CXXFLAGS = $(PIN_COMMON_CXXFLAGS) $(PIN_EXTRA_CXXFLAGS)
PIN_LDFLAGS  = $(PIN_COMMON_LDFLAGS) $(PIN_EXTRA_LDFLAGS)

PIN_CXXFLAGS_NOOPT := $(PIN_CXXFLAGS)
ifeq ($(DEBUG),1)
    PIN_CXXFLAGS += $(PIN_DEBUG_CXXFLAGS)
    PIN_LDFLAGS  += $(PIN_DEBUG_LDFLAGS)
else
    PIN_CXXFLAGS += $(PIN_RELEASE_CXXFLAGS)
    PIN_LDFLAGS  += $(PIN_RELEASE_LDFLAGS)
endif

TARGET_LONG_32 = ia32
TARGET_LONG_64 = intel64

ifeq ($(TARGET),ia32)
    TARGET_LONG   = $(TARGET_LONG_32)
    PIN_CXXFLAGS += $(PIN_IA32_CXXFLAGS) $(PIN_EXTRA_IA32_CXXFLAGS)
    PIN_CXXFLAGS_NOOPT += $(PIN_IA32_CXXFLAGS) $(PIN_EXTRA_IA32_CXXFLAGS)
    PIN_LDFLAGS  += $(PIN_IA32_LDFLAGS)  $(PIN_EXTRA_IA32_LDFLAGS)
    PIN_LIBS      = $(PIN_COMMON_LIBS) $(PIN_IA32_LIBS) ws2_32.lib
    MASM          = ml
endif

ifeq ($(TARGET),ia32e)
    TARGET_LONG   = $(TARGET_LONG_64)
    PIN_CXXFLAGS += $(PIN_IA32E_CXXFLAGS) $(PIN_EXTRA_IA32E_CXXFLAGS)
    PIN_CXXFLAGS_NOOPT += $(PIN_IA32E_CXXFLAGS) $(PIN_EXTRA_IA32E_CXXFLAGS)
    PIN_LDFLAGS  += $(PIN_IA32E_LDFLAGS)  $(PIN_EXTRA_IA32E_LDFLAGS)
    PIN_LIBS      = $(PIN_COMMON_LIBS) $(PIN_IA32E_LIBS) ws2_32.lib
    MASM          = ml64
endif

ifneq ($(CCOV),)
    PIN_LIBS += $(PIN_ICL_CODE_COVERAGE_LIBS)
endif

ifneq ($(ICC),)
    CC = $(ICCL)
    CXX = $(ICXXL)
    PIN_LD = $(XILINKER)
    PIN_LIBS += $(PIN_ICL_LIBS)
endif

TARGET_OS=w
TARGET_OS_LONG=windows


PIN            = $(PIN_NOFLAGS) $(PIN_TEST_FLAGS)
PIN_TEST_FLAGS = -slow_asserts $(PIN_FLAGS)

TEST_ATTACH = yes
TEST_DETACH = yes

ifeq (${KIT},0)

    #
    # Building out of a source tree
    #

    ifeq (${TARGET},ia32e)
         TARGET_EXT = ia32_intel64
    else
         TARGET_EXT = $(TARGET_LONG)
    endif

    # If you are building out of a source tree and not a kit
    # point this to the charm directory
    PIN_ROOT ?= ../../../../third_party/pin/src/windows/source/

    BUILDDIR      = $(PIN_ROOT)/build/Source
    XEDKIT        = $(BUILDDIR)/xed/xed-msvc-pin-windows-$(TARGET_LONG)/xed2-kit
    PINKIT        = $(BUILDDIR)/pin/pin-W-X-Y-$(TARGET_EXT)-windows
    PIN_IPATHS    = /I$(PIN_ROOT)/PinTools/Include \
                    /I$(PIN_ROOT)/PinTools/InstLib \
                    /I$(XEDKIT)/include \
                    /I$(PIN_ROOT)/Source/atomic/00-export-include \
                    /I$(PIN_ROOT)/Source/fund/00-export-include \
                    /I$(PIN_ROOT)/Source/sync/00-export-include \
                    /I$(PIN_ROOT)/Source/util/00-export-include \
                    /I$(PINKIT)/source/include/pin/gen \
                    /I$(PINKIT)/source/include/pin

    # When cross-building an ia32 tool on an ia32e host, the Pin headers could be in either of two possible places.
    # If only the ia32 Pin kit was built, the headers are in the location specified above.  However, if the combined
    # Pin kit was built, they are in the location specified below.
    ifeq (${TARGET}-${HOST_ARCH},ia32-ia32e)
        PIN_CXXFLAGS += -I$(PIN_ROOT)/build/Source/pin/pin-W-X-Y-ia32_intel64-$(TARGET_OS_LONG)/source/include/pin/gen \
                        -I$(PIN_ROOT)/build/Source/pin/pin-W-X-Y-ia32_intel64-$(TARGET_OS_LONG)/source/include/pin
    endif

    APP_INC_DIRS       = /I$(PIN_ROOT)/Source/atomic/00-export-include \
                         /I$(PIN_ROOT)/Source/fund/00-export-include \
                         /I$(PIN_ROOT)/Source/sync/00-export-include \
                         /I$(PIN_ROOT)/Source/util/00-export-include
    APP_LIB_ATOMIC     = $(PINKIT)/extras/components/lib/$(TARGET_LONG)/atomic.lib

    PIN_LPATHS         = /LIBPATH:$(BUILDDIR)/pin/pin-windows-$(TARGET_LONG) \
                         /LIBPATH:$(PIN_ROOT)/External/Ntdll/Lib_${TARGET_LONG}_windows \
                         /LIBPATH:$(XEDKIT)/lib
    PIN_LIBNAMES       = $(BUILDDIR)/pin/pin-windows-$(TARGET_LONG)/pin.lib

    PIN_EXE_32         = $(BUILDDIR)/pin/pin-windows-$(TARGET_LONG_32)/pin.exe
    PIN_EXE_64         = $(BUILDDIR)/pin/pin-windows-$(TARGET_LONG_64)/pin.exe
    PIN_EXE            = $(BUILDDIR)/pin/pin-windows-$(TARGET_LONG)/pin.exe
    PIN_NOFLAGS        = $(PIN_EXE)
    PINDB              = $(BUILDDIR)/pindb/export-windows-${TARGET_LONG}/pindb.exe
    PINDB_LIBPATH      =
    PINDB_WITH_LIBPATH = $(PINDB)

else

    #
    # Building out of a kit
    #

    ifneq ($(UCRT_INCLUDE),)
      I_UCRT_INCLUDE=/I$(UCRT_INCLUDE)
    endif
    
    ifdef __LINT__
      LINT_CXXFLAGS="-e686 -wlib(0)"
    endif

    PIN_EXE_32         = $(PIN_KIT)/$(TARGET_LONG_32)/bin/pin.exe
    PIN_EXE_64         = $(PIN_KIT)/$(TARGET_LONG_64)/bin/pin.exe
    PIN_EXE            = $(PIN_KIT)/$(TARGET_LONG)/bin/pin.exe
    PIN_NOFLAGS        = $(PIN_KIT)/pin.exe
    PINDB              = $(PIN_KIT)/$(TARGET_LONG)/bin/pindb.exe
    PINDB_LIBPATH      =
    PINDB_WITH_LIBPATH = $(PINDB)

    XEDKIT             = $(PIN_KIT)/extras/xed2-$(TARGET_LONG)
    PIN_IPATHS         = /I$(VSPATH)include \
                         $(I_UCRT_INCLUDE) \
                         /I$(MSSDK)include/um \
                         /I$(MSSDK)include/shared \
			 /I$(PIN_KIT)/source/include/pin \
                         /I$(PIN_KIT)/source/include/pin/gen \
                         /I$(PIN_KIT)/source/tools/InstLib \
                         /I$(XEDKIT)/include \
                         /I$(PIN_KIT)/extras/components/include

    PIN_LPATHS         = /LIBPATH:$(PIN_KIT)/$(TARGET_LONG)/lib /LIBPATH:$(PIN_KIT)/$(TARGET_LONG)/lib-ext \
                         /LIBPATH:$(XEDKIT)/lib

    APP_INC_DIRS       = /I$(PIN_KIT)/extras/components/include
    APP_LIB_ATOMIC     = $(PIN_KIT)/extras/components/lib/$(TARGET_LONG)/atomic.lib

endif


# append include/lib paths to compiler/linker flags
PIN_CXXFLAGS +=  ${PIN_IPATHS} ${LINT_CXXFLAGS}
PIN_CXXFLAGS_NOOPT +=  ${PIN_IPATHS}
PIN_LDFLAGS  +=  ${PIN_LPATHS}

###############################################################
# Define build options for test applications
###############################################################

OBJDIR = obj-$(TARGET_LONG)/

TESTAPP           ?= $(PIN_HOME)/Tests/$(OBJDIR)cp-pin.exe

APP_CXXFLAGS      = /nologo /DTARGET_WINDOWS /DFUND_TC_HOSTOS=FUND_OS_WINDOWS /DFUND_TC_TARGETOS=FUND_OS_WINDOWS $(APP_INC_DIRS) /MD /EHa /Gy-
APP_CXXFLAGS2     = /nologo /DTARGET_WINDOWS /DFUND_TC_HOSTOS=FUND_OS_WINDOWS /DFUND_TC_TARGETOS=FUND_OS_WINDOWS $(APP_INC_DIRS) /EHa /Gy-
NO_COMDAT_FLAG    = /Gy-
APP_CXXLINK_FLAGS = /link /NOLOGO /INCREMENTAL:NO /OPT:NOREF
# Disable voluntary image relocation, has effect since VS2010
APP_CXXLINK_FLAGS_NORANDOM = $(APP_CXXLINK_FLAGS) /DYNAMICBASE:NO
APP_SHLINKFLAGS = /dll

ifeq ($(TARGET),ia32)
    APP_CXXFLAGS += /DTARGET_IA32 /DFUND_TC_HOSTCPU=FUND_CPU_IA32 /DFUND_TC_TARGETCPU=FUND_CPU_IA32
    APP_CXXFLAGS2 += /DTARGET_IA32 /DFUND_TC_HOSTCPU=FUND_CPU_IA32 /DFUND_TC_TARGETCPU=FUND_CPU_IA32
endif

ifeq ($(TARGET),ia32e)
    APP_CXXFLAGS += /DTARGET_IA32E /DFUND_TC_HOSTCPU=FUND_CPU_INTEL64 /DFUND_TC_TARGETCPU=FUND_CPU_INTEL64
    APP_CXXFLAGS2 += /DTARGET_IA32E /DFUND_TC_HOSTCPU=FUND_CPU_INTEL64 /DFUND_TC_TARGETCPU=FUND_CPU_INTEL64
endif

ifeq ($(DEBUG),1)
  APP_CXXFLAGS   += /Zi
  APP_CXXFLAGS2  += /Zi
  APP_SHLINKFLAGS += /debug
endif

# This doesn't work because automatic testing goes through a cygwin
# ssh.  There is a cygwin bug that prevents the compiler from creating
# PDB files.  See this note:
#
#   http://cygwin.com/ml/cygwin/2008-08/msg00157.html
#
#DBG_INFO_ALWAYS = /Z7
#APP_SHLINK_DBG_ALWAYS = /debug

##############################################################
# Some final variables
##############################################################

OPT          = /O2
NO_OPTIMIZE  = /Od
COPT         = /c
OUTOPT       = /Fo
OUTEXE       = /Fe
LINK_OUT     = /OUT:
EXEEXT       = .exe
SHLIBEXT     = .dll
OBJEXT       = obj
NO_LOGO      = /nologo
ifeq ($(TARGET),ia32)
  SSE2            = /arch:SSE2
  ifdef ICC
    ICC_NO_SSE    = /arch:ia32
  endif
endif

PINTOOL_SUFFIX  = .dll
PIN_CMP         = cmp
PIN_DIFF        = diff -w

APP_CXX=$(CXX)
APP_CC=$(CC)

##############################################################
# Rules to make testing easier
# This testing only checks that the application ran correctly.
# It does no checking of the results of the tool.
# If you make the tool self checking and exit with a non zero exit code,
# then it will detect the error
# Before the test, we make a .tested and a .failed file. If
# the test succeeds, we remove the .failed file.
# find . -name '*.tested'
# and
# find . -name '*.failed'
# will summarize what you tested and what failed
##############################################################
%$(PINTOOL_SUFFIX).test : $(OBJDIR)%$(PINTOOL_SUFFIX) %$(PINTOOL_SUFFIX).tested %$(PINTOOL_SUFFIX).failed
	touch $*.makefile.copy; rm $*.makefile.copy
	$(PIN) -t $< -- $(TESTAPP) makefile $*.makefile.copy
	$(PIN_CMP) makefile $*.makefile.copy
	rm $*.makefile.copy; rm $*$(PINTOOL_SUFFIX).failed

# Some subdirectories do not want the $(PINTOOL_SUFFIX) in their test name.
%.test : $(OBJDIR)%$(PINTOOL_SUFFIX) %$(PINTOOL_SUFFIX).tested %$(PINTOOL_SUFFIX).failed
	touch $*.makefile.copy; rm $*.makefile.copy
	$(PIN) -t $< -- $(TESTAPP) makefile $*.makefile.copy
	$(PIN_CMP) makefile $*.makefile.copy
	rm $*.makefile.copy; rm $*$(PINTOOL_SUFFIX).failed


%.tested :
	touch $@

%.failed :
	touch $@

# otherwise these are deleted if the tool build fails
.PRECIOUS : %.tested %.failed

all:

.PHONY: dir
dir:
	mkdir -p $(OBJDIR)
